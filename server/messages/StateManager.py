import asyncio
import json

from server.messages.StateSentinel import StateSentinel


class StateManager:
    def __init__(self, connectionManager, messageBus, event_loop):
        self.connectionManager = connectionManager
        self.messageBus = messageBus
        self.event_loop = event_loop

    async def broadcast_connected_users_list(self) -> None:
        # This needs to be reworked into something more useful
        count = {"type": "users", "count": self.connectionManager.get_client_count()}
        await self.messageBus.broadcast_message(json.dumps(count))

    async def send_state_values_to_client(self, websocket):
        """ Gets data required by client layout and sends directly to client via MQ message """
        state_values = self.connectionManager.get_client(websocket).construct_state()
        # !!!! When is state data actually ever sent to more than one client? This is a per-instance concern.
        if state_values["external_fulfillment"] is False:   # Some state requests need to be fulfilled by the microservices that manage those modes
            await self.messageBus.direct_message(json.dumps(state_values["state_values"]), self.connectionManager.get_client(websocket).get_uuid())
        else:
            await self.messageBus.add_to_events_queue(json.dumps(state_values["state_values"]), state_values["header"])

    async def update_dashboard_state(self):
        # Um.. no. Admin dashboards can have all updates but all other dashboards need to fetch their own updates. Best to leave
        # this to each individual dashboard to find.
        # Are we updating all possible attached dashboards? Is that what should be happening?
        active_dashboards = self.connectionManager.get_connected_dashboards()
        for dashboard_type in active_dashboards.keys():
            # But these all use the same static function for generating the state_vals!
            websocket = next(iter(active_dashboards[dashboard_type]))   # Get the first dashboard (websocket) from set
            state_values = self.connectionManager.get_client(websocket).construct_state()
            await self.messageBus.broadcast_event_update_by_key(json.dumps(state_values["state_values"]), dashboard_type)

    async def get_initial_state(self, websocket):
        """ Initial state is sent directly to client queue. State is generated by client object. """
        await self.notify_claver_clients_of_new_connection(websocket)
        await self.send_state_values_to_client(websocket)

    async def notify_claver_clients_of_new_connection(self, websocket):
        await self.broadcast_connected_users_list()
        if self.connectionManager.get_client(websocket).get_agent() == "node":
            if len(self.connectionManager.get_connected_dashboards()) > 0:
                await self.update_dashboard_state()

    async def notify_claver_clients_of_closed_connection(self, agent):
        await self.broadcast_connected_users_list()
        if agent == "node":
            if len(self.connectionManager.get_connected_dashboards()) > 0:
                await self.update_dashboard_state()