import asyncio
import json

from server.messages.StateSentinel import StateSentinel


class StateManager:
    def __init__(self, connectionManager, messageBus, event_loop):
        self.connectionManager = connectionManager
        self.messageBus = messageBus
        self.event_loop = event_loop

    async def broadcast_connected_users_list(self) -> None:
        # This needs to be reworked into something more useful
        count = {"type": "users", "count": self.connectionManager.get_client_count()}
        await self.messageBus.broadcast_message(json.dumps(count))

    async def send_state_values_to_client(self, websocket):
        """ Gets data required by client layout and sends directly to client via MQ message """
        state_values = self.connectionManager.get_client(websocket).construct_state()
        # !!!! When is state data actually ever sent to more than one client? This is a per-instance concern.
        if state_values["external_fulfillment"] is False:   # Some state requests need to be fulfilled by the microservices that manage those modes
            await self.messageBus.direct_message(json.dumps(state_values["state_values"]), self.connectionManager.get_client(websocket).get_uuid())
        else:
            await self.messageBus.add_to_events_queue(json.dumps(state_values["state_values"]), state_values["header"])

    async def update_dashboard_state(self):
        """ Adds request to the Rabbit message queue for each dashboard mode to update state values """
        active_dashboards = self.connectionManager.get_connected_dashboard_modes()
        for dashboard_type in active_dashboards:
            message = {"channel_type": 'direct', "action": {"update": {"display": "state_values"}}}
            await self.messageBus.broadcast_event_update_by_key(json.dumps(message), dashboard_type)

    async def get_initial_state(self, websocket):
        """ Initial state is sent directly to client queue. State is generated by client object. """
        await self.notify_claver_clients_of_new_connection(websocket)
        await self.send_state_values_to_client(websocket)

    async def notify_claver_clients_of_new_connection(self, websocket):
        await self.broadcast_connected_users_list()
        if self.connectionManager.get_client(websocket).get_agent() == "node":
            if len(self.connectionManager.get_connected_dashboard_modes()) > 0:
                await self.update_dashboard_state()

    async def notify_claver_clients_of_closed_connection(self, agent):
        await self.broadcast_connected_users_list()
        if agent == "node":
            if len(self.connectionManager.get_connected_dashboard_modes()) > 0:
                await self.update_dashboard_state()